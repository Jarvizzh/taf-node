#TAF_JAVA学习五

## 熔断机制与负载均衡策略

### 一、熔断机制

上一篇笔记（[客户端请求过程](./客户端请求过程.md)) 中已经描述过，客户端调用服务的时候，Invoker调用doInvokeServant方法处理请求后再finally代码段里都会对服务节点进行死活检查，主要由ServantnvokerAliveChecker工具类执行。

以下情况会触发死活检查（Invoker调用doInvokeServant方法处理请求后再finally代码段里）：

- 同步调用（无论成败）
- 异步调用失败
- 异步调用成功，但是无callback

```java
public static boolean isAlive(URL url, ServantProxyConfig config, int ret) {
    ServantInvokerAliveStat stat = get(url);
    stat.onCallFinished(ret, config);
    return stat.isAlive();
}
```

ServantInvokerAliveStat类主要记录Invoker节点存活状态，一个URL对象对应一个ServantInvokerAliveStat对象，由URL的toIdentityString方法生成identity （eg: "jce://host:port/path"）来实例化ServantInvokerAliveStat对象，其onCallFinished 方法会根据一些策略判断是否屏蔽某些故障节点，且看源码分析：

```java
public synchronized void onCallFinished(int ret, ServantProxyConfig config) {
    if (ret == Constants.INVOKE_STATUS_SUCC) { //执行成功
        frequenceFailInvoke = 0;
        frequenceFailInvoke_startTime = 0;
        lastCallSucess.set(true);
        netConnectTimeout = false;
        succCount++;
    } else if (ret == Constants.INVOKE_STATUS_TIMEOUT) {  //超时
        //上一次调用成功
        if (!lastCallSucess.get()) {
            frequenceFailInvoke++; //频繁调用失败统计数+1
        } else {
            lastCallSucess.set(false);
            frequenceFailInvoke = 1;
            frequenceFailInvoke_startTime = System.currentTimeMillis();
        }
        netConnectTimeout = false;
        timeoutCount++;  //超时次数+1
    } else if (ret == Constants.INVOKE_STATUS_EXEC) {
        if (!lastCallSucess.get()) {
            frequenceFailInvoke++;
        } else {
            lastCallSucess.set(false);
            frequenceFailInvoke = 1;
            frequenceFailInvoke_startTime = System.currentTimeMillis();
        }
        netConnectTimeout = false;
        failedCount++; //调用失败次数+1
    } else if (ret == Constants.INVOKE_STATUS_NETCONNECTTIMEOUT) {
        netConnectTimeout = true; //网络连接超时
    }

    /** 死活检查周期 checkInterval = 60 * 1000 = 60s; **/
    if ((timeout_startTime + config.getCheckInterval()) < System.currentTimeMillis()) {
        timeoutCount = 0;
        failedCount = 0;
        succCount = 0;
        timeout_startTime = System.currentTimeMillis();
    }

    if (alive) {
        long totalCount = timeoutCount + failedCount + succCount;
        //死活检查周期内超时次数超过n次（默认20次）且超时比率>frequenceFailRadio(默认50%)
        if (timeoutCount >= config.getMinTimeoutInvoke()) {
            double radio = div(timeoutCount, totalCount, 2);
            if (radio > config.getFrequenceFailRadio()) {
                alive = false;
                ClientLogger.getLogger().info(identity + "|alive=false|radio=" + radio + "|" + toString());
            }
        }

        if (alive) {
            // 5秒内连续失败n次 默认50次
            if (frequenceFailInvoke >= config.getFrequenceFailInvoke() && (frequenceFailInvoke_startTime + 5000) > System.currentTimeMillis()) {
                alive = false;
                ClientLogger.getLogger().info(identity + "|alive=false|frequenceFailInvoke=" + frequenceFailInvoke + "|" + toString());
            }
        }

        if (alive) {
            //网络连接超时
            if (netConnectTimeout) {
                alive = false;
                ClientLogger.getLogger().info(identity + "|alive=false|netConnectTimeout" + "|" + toString());
            }
        }
    } else {
        if (ret == Constants.INVOKE_STATUS_SUCC) {
            alive = true;
        }
    }
}
```

#### 屏蔽服务节点条件

不难发现，只要满足以下三种情况的任一种则客户端会主动屏蔽该服务节点，服务节点置为不可用：

1.  死活检查周期内（默认60s）超时次数超过 minTimeoutInvoke 次（默认20次），且超时比率 > frequenceFailRadio (默认50%)
2.  5秒内连续失败 frequenceFailInvoke 次（默认50次）
3.  网络连接超时1次

一个周期之后，统计指标重计。**某次服务节点为不可用状态，若下一次请求返回成功，则节点置为可用。**

这些属性可以通过ServantProxyConfig配置

```java
public final class ServantProxyConfig {
//省略... 
    /** 死活检查周期 */
    private int checkInterval = 60 * 1000;
    /** 客户端每tryTimeInterval秒中重试一次失效的ip */
    private int tryTimeInterval = 30;
    /** 在检查周期内超时次数至少超过MinTimeoutInvoke次并且超时个数比例大于等于总数的frequenceFailRadio，屏蔽 */
    private int minTimeoutInvoke = 20;
    /** 连续调用超过frequenceFailInvoke次（5秒内）超时，屏蔽 */
    private int frequenceFailInvoke = 50;
    private float frequenceFailRadio = 0.5f;

// ... 

    /** 静态权重路由限制 **/
    private int minStaticWeightLimit = 10;
    private int maxStaticWeightLimit = 100;

    /** 一致性hash虚拟节点数 **/
    private int defaultConHashVirtualNodes = 100;
// ...
```

#### 熔断后尝试  

- 服务节点为不可用状态下，每隔30s会尝试使用不可用的节点发起一次请求 （DefaultLoadBalance.java 的 select() 方法），如果请求成功则节点重新置为可用。

```java
ServantInvokerAliveStat stat = ServantnvokerAliveChecker.get(invoker.getUrl());
//屏敝后尝试重新调用， tryTimeInterval默认30
if (stat.isAlive() || (stat.getLastRetryTime() + (config.getTryTimeInterval() * 1000)) < System.currentTimeMillis()) {
    //....
}
```



### 二、负载均衡





